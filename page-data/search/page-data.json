{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"call 첫번째 인자인 obj가 this를 대체함\nthis는 기본적으로 window를 가리킴\n하지만 call, apply, bind의 첫번째 인자에서 this를 바꿀 수 있음 apply arguments는 기본적으로 유사배열이므로 배열의 프로토타입인 slice 메소드를 사용할 수 없음\n하지만 apply()를 사용하여 arguments를 바인딩 하면 배열처…","fields":{"slug":"/call apply bind/"},"frontmatter":{"date":"July 26, 2024","title":"call / bind / apply","tags":["javascript"]},"rawMarkdownBody":"\r\n\r\n## call\r\n\r\n```js\r\nvar obj = { b: \"발\" };\r\n\r\nvar example = function (a) {\r\n  return a + this.b;\r\n};\r\n\r\nexample('닭'); // 닭undefined\r\nexample.call(obj, '닭'); // 닭발\r\n```\r\n\r\n첫번째 인자인 obj가 this를 대체함\r\nthis는 기본적으로 window를 가리킴\r\n하지만 call, apply, bind의 첫번째 인자에서 this를 바꿀 수 있음\r\n\r\n## apply\r\n\r\n```js\r\nfunction example() {\r\n  var arr = Array.prototype.slice.apply(arguments);\r\n}\r\nexample(1, 2, 3); // [1, 2, 3]\r\n```\r\n\r\narguments는 기본적으로 유사배열이므로 배열의 프로토타입인 slice 메소드를 사용할 수 없음\r\n하지만 apply()를 사용하여 arguments를 바인딩 하면 배열처럼 사용 가능\r\n\r\n## bind\r\n\r\nbind는 call, apply와 마찬가지로 this를 바꾸지만 호출은 하지 않음\r\nbind()()로 하면 호출까지 가능 !\r\n\r\n\r\n## 참고\r\n\r\n- https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-Call-Bind-Apply"},{"excerpt":"실행 가능한 자바스크립트의 코드 블록 실행 컨텍스트란 실행할 코드에 제공할 환경 정보들을 모아놓은 객체 여기서 환경이란 전역공간 혹은 함수 내부의 환경을 의미 해당 환경에는 변수, 함수, this, arguments 등에 대한 정보를 담고 있음 자바스크립트 엔진에서 코드가 실행 된다는 것은 실행 컨텍스트 내부에서 코드가 실행되고 있다는 의미 컨텍스트 종류…","fields":{"slug":"/execution context/"},"frontmatter":{"date":"July 02, 2024","title":"Execution Context(실행 컨텍스트)란","tags":["javascript"]},"rawMarkdownBody":"\n## 실행 가능한 자바스크립트의 코드 블록\n\n> 실행 컨텍스트란 실행할 코드에 제공할 환경 정보들을 모아놓은 객체  \n> 여기서 환경이란 전역공간 혹은 함수 내부의 환경을 의미  \n> 해당 환경에는 변수, 함수, this, arguments 등에 대한 정보를 담고 있음  \n> 자바스크립트 엔진에서 코드가 실행 된다는 것은 실행 컨텍스트 내부에서 코드가 실행되고 있다는 의미\n\n<br/>\n\n## 컨텍스트 종류\n\n자바스크립트의 코드는 아래 세 종류가 있음\n\n1. 글로벌 스코프에서 실행하는 글로벌 코드\n2. 함수 스코프에서 실행하는 함수 코드\n3. eval()로 강제 실행되는 코드 (사용하지 않음)\n\n<br/>\n\n각각의 코드는 자신만의 실행 컨텍스트를 생성  \n엔진이 스크립트 파일 실행 전 글로벌 실행 컨텍스트(GEC)가 생성되고,  \n함수가 호출될 때마다 함수 실행 컨텍스트(FEC)가 생성되어  \n자바스크립트 엔진의 Call Stack이라는 곳에 쌓이게 됨\n\n\n### 예시\n\n```js\n// 1\n\nlet hi = \"Hi\";\n\nfunction foo() {\n  let hello = \"Hello\";\n}\n\nfunction bar() {\n  foo(); // 3\n}\n\nbar(); // 2\n```\n\n1. 가장 먼저 글로벌 실행 컨텍스트(GEC) 생성  \n   스택의 가장 아래에 위치\n2. bar() 함수 호출 시 해당 함수의 함수 실행 컨텍스트(FEC) 생성  \n   1에서 생성된 GEC 위로 올라감\n3. bar() 함수 안에서 foo() 호출 시 또 다른 FEC 생성  \n   2에서 생성된 FEC 위로 올라감\n4. foo() 함수 리턴 시 3에서 생성된 FEC를 스택에서 제거\n5. bar() 함수 리턴 시 2에서 생성된 FEC를 스택에서 제거\n6. GEC만 남음\n\n<br/>\n\n## 컨텍스트 구성 요소\n\n### 1. Variable Environment\n\n현재 컨텍스트 내부의 식별자 정보인 'Environment Record'와\n외부 환경 정보 'Outer Environment Reference'가 포함되어 있음  \nVariable Environment에 먼저 정보를 담고, Lexical Environment에 복사해서 사용\n\n### 2. Lexical Environment\n\n초기에는 Variable Environment와 같지만 변경사항이 실시간으로 적용 되므로 최신 상태를 저장하고 있음\n\n### 예시\n\n```js\nlet hi = \"Hi\";\n\nfunction foo() {\n  let hello = \"Hello\";\n  console.log(hi);\n}\n\nfoo();\n```\n\n- foo() 함수에서 hello는 Environment Record\n- foo() 함수에서 hi 호출 시 Outer Environment Reference를 통해 상위 컨텍스트에 접근 가능\n- 순서: Environment Record -> Outer Environment Reference\n- 위 과정을 스코프 체인이라고 함\n\n### 3. This Binding\n\nthis는 현재 컨텍스트를 가리킴\n\n<br/>\n\n## 참고\n\n- https://github.com/baeharam/Must-Know-About-Frontend/blob/main/Notes/javascript/execution-context.md\n- https://gamguma.dev/post/2022/04/js_execution_context\n- https://blog.naver.com/dlaxodud2388/222655214381\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}