{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"Debounce란 연속적으로 발생한 이벤트를 하나로 처리하는 방식\n입력이 계속 들어오면 실행 타이머가 계속 초기화 됨\n 예제 input 이벤트 함수를 타이핑 할 때마다가 아닌 입력을 멈춘 후 일정 시간이 지난 후 실행 resize 이벤트 함수를 resize 할 때마다가 아닌 resize 완료 후 실행\n Throttle란 이벤트를 일정한 주기마다 발생하도록…","fields":{"slug":"/debounce throttle/"},"frontmatter":{"date":"March 17, 2025","title":"Debounce / Throttle","tags":["javascript"]},"rawMarkdownBody":"\n\n## Debounce란\n연속적으로 발생한 이벤트를 하나로 처리하는 방식<br>\n입력이 계속 들어오면 실행 타이머가 계속 초기화 됨\n<br/><br/>\n### 예제\n- input 이벤트 함수를 타이핑 할 때마다가 아닌 입력을 멈춘 후 일정 시간이 지난 후 실행\n- resize 이벤트 함수를 resize 할 때마다가 아닌 resize 완료 후 실행\n<br/><br/>\n\n```js\n// debounce를 사용한 훅\n\nimport { useEffect, useState } from \"react\";\n\n/**\n * 입력이 멈춘 후 일정 시간이 지나면 값을 업데이트하는 Debounce 훅\n * @param value 변경되는 값 (ex: input 값)\n * @param delay 지연 시간 (기본값: 500ms)\n * @returns delay 후에 업데이트된 값\n */\nexport const useDebounce = (value: any, delay: number = 500) => {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    // delay 후에 debouncedValue를 업데이트하는 타이머 설정\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    // 값이 변경될 때마다 기존 타이머를 제거하고 새로운 타이머 시작 (즉, 입력 중이면 실행되지 않음)\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n};\n\n```\n\n## Throttle란\n이벤트를 일정한 주기마다 발생하도록 하는 방식<br>\n마지막 입력 여부와 관계없이 주어진 간격마다 실행\n<br/><br/>\n### 예제\n- 일정 시간마다 scroll 감지\n- 실시간 UI 업데이트\n<br/><br/>\n\n```js\n// throttle를 사용한 훅\n\nimport { useEffect, useState } from \"react\";\n\n/**\n * 일정 간격마다 값이 업데이트되는 Throttle 훅\n * @param value 변경되는 값 (ex: 입력값, 스크롤 값)\n * @param limit 실행 간격 시간 (기본값: 500ms)\n * @returns 일정 간격마다 업데이트된 값\n */\nexport const useThrottle = (value: any, limit: number = 500) => {\n  const [throttledValue, setThrottledValue] = useState(value);\n  const [lastUpdated, setLastUpdated] = useState(0);\n\n  useEffect(() => {\n    const now = Date.now();\n\n    // 마지막 업데이트 이후 limit(ms) 시간이 지나면 실행\n    if (now - lastUpdated >= limit) {\n      setThrottledValue(value);\n      setLastUpdated(now);\n    }\n  }, [value, limit, lastUpdated]);\n\n  return throttledValue;\n};\n\n\n```\n## 비교\n|  | **Debounce** | **Throttle** |\n|---|---|---|\n| 📌 실행 시점 | 입력이 멈춘 후 일정 시간이 지나야 실행됨 | 일정한 시간 간격마다 실행됨 |\n| 🛠️ 사용 사례 | 검색어 자동완성, 버튼 중복 클릭 방지 | 스크롤 감지, 실시간 UI 업데이트 |\n| ✅ 장점 | 불필요한 API 호출 방지 | 성능 최적화 (이벤트 과부하 방지) |\n\n\n\n## 참고\n\n- https://velog.io/@jiynn_12/Debounce-%EC%99%80-throttle-%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B3%A0-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90-%EC%A0%81%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90\n"},{"excerpt":"closure의 사용 1. 데이터 은닉(캠슐화) 자바스크립트에서는 제공하지 않는 private method 기능 구현 가능 private method : 같은 클래스 내부의 특정 메서드에서만 해당 메서드 호출 가능 2. 상태 유지 closure의 사전적 의미는 '폐쇠' 특정 데이터를 스코프 안에 가두어 둔 채로 계속 사용 가능 -> 메모리 측면에서 손해 …","fields":{"slug":"/closure_2/"},"frontmatter":{"date":"August 02, 2024","title":"Closure (2)","tags":["javascript"]},"rawMarkdownBody":"\r\n## closure의 사용\r\n\r\n### 1. 데이터 은닉(캠슐화)\r\n자바스크립트에서는 제공하지 않는 private method 기능 구현 가능  \r\nprivate method : 같은 클래스 내부의 특정 메서드에서만 해당 메서드 호출 가능\r\n\r\n\r\n```js\r\nconst makeCounter = function () {\r\n  let privateCounter = 0;\r\n  function changeBy(val) {\r\n    privateCounter += val;\r\n  }\r\n  return {\r\n    increment() {\r\n      changeBy(1);\r\n    },\r\n\r\n    decrement() {\r\n      changeBy(-1);\r\n    },\r\n\r\n    value() {\r\n      return privateCounter;\r\n    },\r\n  };\r\n};\r\n\r\nconst counter1 = makeCounter();\r\nconst counter2 = makeCounter();\r\n\r\nconsole.log(counter1.value()); // 0.\r\n\r\ncounter1.increment();\r\ncounter1.increment();\r\nconsole.log(counter1.value()); // 2.\r\n\r\ncounter1.decrement();\r\nconsole.log(counter1.value()); // 1.\r\nconsole.log(counter2.value()); // 0.\r\n```\r\n\r\n### 2. 상태 유지\r\nclosure의 사전적 의미는 '폐쇠'  \r\n특정 데이터를 스코프 안에 가두어 둔 채로 계속 사용 가능  \r\n-> 메모리 측면에서 손해\r\n\r\n```js\r\nfunction Counter() {\r\n    let count = 0;\r\n\r\n    function increment() {\r\n        count += 1;\r\n        console.log(count);\r\n    }\r\n\r\n    return increment;\r\n}\r\n\r\nconst counter = Counter();\r\ncounter(); // 1\r\ncounter(); // 2\r\ncounter(); // 3\r\n```\r\n\r\n\r\n<br/>\r\n\r\n## 참고\r\n- https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures\r\n- https://adjh54.tistory.com/64\r\n"},{"excerpt":"closure란 클로저는 부모 함수 안에서 자식 함수를 선언하면 자식함수를 어디에서 호출하더라도 자식함수 안에서 부모함수의 변수에 접근할 수 있음\n\n   fn2의 스코프에서 fn1의 값을 가지고 올 수 없음  local -> closure -> script closure에서 찾은 l1값 ! -> 함수를 다른 함수 내에 정의 하면 부모 함수의 스코프에 접근…","fields":{"slug":"/closure/"},"frontmatter":{"date":"August 01, 2024","title":"Closure (1)","tags":["javascript"]},"rawMarkdownBody":"\r\n## closure란\r\n클로저는 부모 함수 안에서 자식 함수를 선언하면  \r\n자식함수를 어디에서 호출하더라도 자식함수 안에서 부모함수의 변수에 접근할 수 있음\r\n<br/>\r\n<br/>  \r\n\r\n```js\r\nlet l0 = 'l0';\r\n\r\nfunction fn2() {\r\n    let l2 = 'l2';\r\n    console.log(l0, l1, l2); // error\r\n}\r\n\r\nfunction fn1() {\r\n    let l1 = 'l1';\r\n}\r\n\r\nfn1();\r\n```\r\nfn2의 스코프에서 fn1의 값을 가지고 올 수 없음  \r\n<br/>\r\n\r\n```js\r\nlet l0 = 'l0';\r\n\r\n\r\nfunction fn1() {\r\n    function fn2() {\r\n        // fn2()는 내부 함수이자 클로저\r\n        let l2 = 'l2';\r\n        console.log(l0, l1, l2); // l0 l1 l2\r\n    }\r\n\r\n    let l1 = 'l1';\r\n    fn2();\r\n}\r\n\r\nfn1();\r\n```\r\nlocal -> closure -> script  \r\nclosure에서 찾은 l1값 !  \r\n-> 함수를 다른 함수 내에 정의 하면 부모 함수의 스코프에 접근 가능  \r\n\r\n## dynamic scope (동적 스코프)\r\n어디서 호출 하느냐에 따라 접근할 수 있는 유효범위가 달라지는 것   \r\nbut javascript는 정적 스코프  \r\n\r\n## static scope, lexical scope (정적 스코프)\r\n어디서 호출 했느냐가 아니라  \r\n어디서 정의 되었느냐에 따라 유효 범위가 달라짐  \r\n\r\n<br/>\r\n\r\n## 참고\r\n\r\n- https://www.youtube.com/watch?v=bwwaSwf7vkE\r\n- https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures"},{"excerpt":"call 첫번째 인자인 obj가 this를 대체함 this는 기본적으로 window를 가리킴 하지만 call, apply, bind의 첫번째 인자에서 this를 바꿀 수 있음   apply arguments는 기본적으로 유사배열이므로 배열의 프로토타입인 slice 메소드를 사용할 수 없음 하지만 apply()를 사용하여 arguments를 바인딩 하면 배…","fields":{"slug":"/call apply bind/"},"frontmatter":{"date":"July 26, 2024","title":"call / bind / apply","tags":["javascript"]},"rawMarkdownBody":"\r\n\r\n## call\r\n\r\n```js\r\nvar obj = { b: \"발\" };\r\n\r\nvar example = function (a) {\r\n  return a + this.b;\r\n};\r\n\r\nexample('닭'); // 닭undefined\r\nexample.call(obj, '닭'); // 닭발\r\n```\r\n\r\n첫번째 인자인 obj가 this를 대체함  \r\nthis는 기본적으로 window를 가리킴  \r\n하지만 call, apply, bind의 첫번째 인자에서 this를 바꿀 수 있음  \r\n\r\n## apply\r\n\r\n```js\r\nfunction example() {\r\n  var arr = Array.prototype.slice.apply(arguments);\r\n}\r\nexample(1, 2, 3); // [1, 2, 3]\r\n```\r\n\r\narguments는 기본적으로 유사배열이므로 배열의 프로토타입인 slice 메소드를 사용할 수 없음  \r\n하지만 apply()를 사용하여 arguments를 바인딩 하면 배열처럼 사용 가능  \r\n\r\n## bind\r\n\r\nbind는 call, apply와 마찬가지로 this를 바꾸지만 호출은 하지 않음  \r\nbind()()로 하면 호출까지 가능 !  \r\n\r\n\r\n## 참고\r\n\r\n- https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-Call-Bind-Apply\r\n"},{"excerpt":"실행 가능한 자바스크립트의 코드 블록 실행 컨텍스트란 실행할 코드에 제공할 환경 정보들을 모아놓은 객체 여기서 환경이란 전역공간 혹은 함수 내부의 환경을 의미 해당 환경에는 변수, 함수, this, arguments 등에 대한 정보를 담고 있음 자바스크립트 엔진에서 코드가 실행 된다는 것은 실행 컨텍스트 내부에서 코드가 실행되고 있다는 의미 컨텍스트 종류…","fields":{"slug":"/execution context/"},"frontmatter":{"date":"July 02, 2024","title":"Execution Context(실행 컨텍스트)란","tags":["javascript"]},"rawMarkdownBody":"\n## 실행 가능한 자바스크립트의 코드 블록\n\n> 실행 컨텍스트란 실행할 코드에 제공할 환경 정보들을 모아놓은 객체  \n> 여기서 환경이란 전역공간 혹은 함수 내부의 환경을 의미  \n> 해당 환경에는 변수, 함수, this, arguments 등에 대한 정보를 담고 있음  \n> 자바스크립트 엔진에서 코드가 실행 된다는 것은 실행 컨텍스트 내부에서 코드가 실행되고 있다는 의미\n\n<br/>\n\n## 컨텍스트 종류\n\n자바스크립트의 코드는 아래 세 종류가 있음\n\n1. 글로벌 스코프에서 실행하는 글로벌 코드\n2. 함수 스코프에서 실행하는 함수 코드\n3. eval()로 강제 실행되는 코드 (사용하지 않음)\n\n<br/>\n\n각각의 코드는 자신만의 실행 컨텍스트를 생성  \n엔진이 스크립트 파일 실행 전 글로벌 실행 컨텍스트(GEC)가 생성되고,  \n함수가 호출될 때마다 함수 실행 컨텍스트(FEC)가 생성되어  \n자바스크립트 엔진의 Call Stack이라는 곳에 쌓이게 됨\n\n\n### 예시\n\n```js\n// 1\n\nlet hi = \"Hi\";\n\nfunction foo() {\n  let hello = \"Hello\";\n}\n\nfunction bar() {\n  foo(); // 3\n}\n\nbar(); // 2\n```\n\n1. 가장 먼저 글로벌 실행 컨텍스트(GEC) 생성  \n   스택의 가장 아래에 위치\n2. bar() 함수 호출 시 해당 함수의 함수 실행 컨텍스트(FEC) 생성  \n   1에서 생성된 GEC 위로 올라감\n3. bar() 함수 안에서 foo() 호출 시 또 다른 FEC 생성  \n   2에서 생성된 FEC 위로 올라감\n4. foo() 함수 리턴 시 3에서 생성된 FEC를 스택에서 제거\n5. bar() 함수 리턴 시 2에서 생성된 FEC를 스택에서 제거\n6. GEC만 남음\n\n<br/>\n\n## 컨텍스트 구성 요소\n\n### 1. Variable Environment\n\n현재 컨텍스트 내부의 식별자 정보인 'Environment Record'와\n외부 환경 정보 'Outer Environment Reference'가 포함되어 있음  \nVariable Environment에 먼저 정보를 담고, Lexical Environment에 복사해서 사용\n\n### 2. Lexical Environment\n\n초기에는 Variable Environment와 같지만 변경사항이 실시간으로 적용 되므로 최신 상태를 저장하고 있음\n\n### 예시\n\n```js\nlet hi = \"Hi\";\n\nfunction foo() {\n  let hello = \"Hello\";\n  console.log(hi);\n}\n\nfoo();\n```\n\n- foo() 함수에서 hello는 Environment Record\n- foo() 함수에서 hi 호출 시 Outer Environment Reference를 통해 상위 컨텍스트에 접근 가능\n- 순서: Environment Record -> Outer Environment Reference\n- 위 과정을 스코프 체인이라고 함\n\n### 3. This Binding\n\nthis는 현재 컨텍스트를 가리킴\n\n<br/>\n\n## 참고\n\n- https://github.com/baeharam/Must-Know-About-Frontend/blob/main/Notes/javascript/execution-context.md\n- https://gamguma.dev/post/2022/04/js_execution_context\n- https://blog.naver.com/dlaxodud2388/222655214381\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}